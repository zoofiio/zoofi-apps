"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5920],{83716:function(t,e,n){n.d(e,{R:function(){return getDefaultState},m:function(){return s}});var r=n(64583),o=n(93242),i=n(76937),s=class extends o.F{#t;#e;#n;constructor(t){super(),this.mutationId=t.mutationId,this.#e=t.mutationCache,this.#t=[],this.state=t.state||getDefaultState(),this.setOptions(t.options),this.scheduleGc()}setOptions(t){this.options=t,this.updateGcTime(this.options.gcTime)}get meta(){return this.options.meta}addObserver(t){this.#t.includes(t)||(this.#t.push(t),this.clearGcTimeout(),this.#e.notify({type:"observerAdded",mutation:this,observer:t}))}removeObserver(t){this.#t=this.#t.filter(e=>e!==t),this.scheduleGc(),this.#e.notify({type:"observerRemoved",mutation:this,observer:t})}optionalRemove(){this.#t.length||("pending"===this.state.status?this.scheduleGc():this.#e.remove(this))}continue(){return this.#n?.continue()??this.execute(this.state.variables)}async execute(t){this.#n=(0,i.Mz)({fn:()=>this.options.mutationFn?this.options.mutationFn(t):Promise.reject(Error("No mutationFn found")),onFail:(t,e)=>{this.#r({type:"failed",failureCount:t,error:e})},onPause:()=>{this.#r({type:"pause"})},onContinue:()=>{this.#r({type:"continue"})},retry:this.options.retry??0,retryDelay:this.options.retryDelay,networkMode:this.options.networkMode,canRun:()=>this.#e.canRun(this)});let e="pending"===this.state.status,n=!this.#n.canStart();try{if(!e){this.#r({type:"pending",variables:t,isPaused:n}),await this.#e.config.onMutate?.(t,this);let e=await this.options.onMutate?.(t);e!==this.state.context&&this.#r({type:"pending",context:e,variables:t,isPaused:n})}let r=await this.#n.start();return await this.#e.config.onSuccess?.(r,t,this.state.context,this),await this.options.onSuccess?.(r,t,this.state.context),await this.#e.config.onSettled?.(r,null,this.state.variables,this.state.context,this),await this.options.onSettled?.(r,null,t,this.state.context),this.#r({type:"success",data:r}),r}catch(e){try{throw await this.#e.config.onError?.(e,t,this.state.context,this),await this.options.onError?.(e,t,this.state.context),await this.#e.config.onSettled?.(void 0,e,this.state.variables,this.state.context,this),await this.options.onSettled?.(void 0,e,t,this.state.context),e}finally{this.#r({type:"error",error:e})}}finally{this.#e.runNext(this)}}#r(t){this.state=(e=>{switch(t.type){case"failed":return{...e,failureCount:t.failureCount,failureReason:t.error};case"pause":return{...e,isPaused:!0};case"continue":return{...e,isPaused:!1};case"pending":return{...e,context:t.context,data:void 0,failureCount:0,failureReason:null,error:null,isPaused:t.isPaused,status:"pending",variables:t.variables,submittedAt:Date.now()};case"success":return{...e,data:t.data,failureCount:0,failureReason:null,error:null,status:"success",isPaused:!1};case"error":return{...e,data:void 0,error:t.error,failureCount:e.failureCount+1,failureReason:t.error,isPaused:!1,status:"error"}}})(this.state),r.V.batch(()=>{this.#t.forEach(e=>{e.onMutationUpdate(t)}),this.#e.notify({mutation:this,type:"updated",action:t})})}};function getDefaultState(){return{context:void 0,data:void 0,error:null,failureCount:0,failureReason:null,isPaused:!1,status:"idle",variables:void 0,submittedAt:0}}},95499:function(t,e,n){n.d(e,{D:function(){return useMutation}});var r=n(77317),o=n(83716),i=n(64583),s=n(7539),a=n(72549),u=class extends s.l{#o;#i=void 0;#s;#a;constructor(t,e){super(),this.#o=t,this.setOptions(e),this.bindMethods(),this.#u()}bindMethods(){this.mutate=this.mutate.bind(this),this.reset=this.reset.bind(this)}setOptions(t){let e=this.options;this.options=this.#o.defaultMutationOptions(t),(0,a.VS)(this.options,e)||this.#o.getMutationCache().notify({type:"observerOptionsUpdated",mutation:this.#s,observer:this}),e?.mutationKey&&this.options.mutationKey&&(0,a.Ym)(e.mutationKey)!==(0,a.Ym)(this.options.mutationKey)?this.reset():this.#s?.state.status==="pending"&&this.#s.setOptions(this.options)}onUnsubscribe(){this.hasListeners()||this.#s?.removeObserver(this)}onMutationUpdate(t){this.#u(),this.#c(t)}getCurrentResult(){return this.#i}reset(){this.#s?.removeObserver(this),this.#s=void 0,this.#u(),this.#c()}mutate(t,e){return this.#a=e,this.#s?.removeObserver(this),this.#s=this.#o.getMutationCache().build(this.#o,this.options),this.#s.addObserver(this),this.#s.execute(t)}#u(){let t=this.#s?.state??(0,o.R)();this.#i={...t,isPending:"pending"===t.status,isSuccess:"success"===t.status,isError:"error"===t.status,isIdle:"idle"===t.status,mutate:this.mutate,reset:this.reset}}#c(t){i.V.batch(()=>{if(this.#a&&this.hasListeners()){let e=this.#i.variables,n=this.#i.context;t?.type==="success"?(this.#a.onSuccess?.(t.data,e,n),this.#a.onSettled?.(t.data,null,e,n)):t?.type==="error"&&(this.#a.onError?.(t.error,e,n),this.#a.onSettled?.(void 0,t.error,e,n))}this.listeners.forEach(t=>{t(this.#i)})})}},c=n(83037),h=n(17275);function useMutation(t,e){let n=(0,c.NL)(e),[o]=r.useState(()=>new u(n,t));r.useEffect(()=>{o.setOptions(t)},[o,t]);let s=r.useSyncExternalStore(r.useCallback(t=>o.subscribe(i.V.batchCalls(t)),[o]),()=>o.getCurrentResult(),()=>o.getCurrentResult()),a=r.useCallback((t,e)=>{o.mutate(t,e).catch(h.Z)},[o]);if(s.error&&(0,h.L)(o.options.throwOnError,[s.error]))throw s.error;return{...s,mutate:a,mutateAsync:s.mutate}}},3599:function(t,e,n){n.d(e,{e:function(){return getConnectorClient}});var r=n(11618),o=n(49168),i=n(56023),s=n(7471),a=n(11043);async function getConnectorClient(t,e={}){let n;if(e.connector){let{connector:r}=e;if("reconnecting"===t.state.status&&!r.getAccounts&&!r.getChainId)throw new a.$S({connector:r});let[o,i]=await Promise.all([r.getAccounts().catch(t=>{if(null===e.account)return[];throw t}),r.getChainId()]);n={accounts:o,chainId:i,connector:r}}else n=t.state.connections.get(t.state.current);if(!n)throw new a.aH;let u=e.chainId??n.chainId,c=await n.connector.getChainId();if(c!==n.chainId)throw new a.XZ({connectionChainId:n.chainId,connectorChainId:c});let h=n.connector;if(h.getClient)return h.getClient({chainId:u});let l=(0,i.T)(e.account??n.accounts[0]);if(l&&(l.address=(0,s.K)(l.address)),e.account&&!n.accounts.some(t=>t.toLowerCase()===l.address.toLowerCase()))throw new a.JK({address:l.address,connector:h});let d=t.chains.find(t=>t.id===u),p=await n.connector.getProvider({chainId:u});return(0,r.e)({account:l,chain:d,name:"Connector Client",transport:t=>(function(t,e={}){let{key:n="custom",methods:r,name:i="Custom Provider",retryDelay:s}=e;return({retryCount:a})=>(0,o.q)({key:n,methods:r,name:i,request:t.request.bind(t),retryCount:e.retryCount??a,retryDelay:s,type:"custom"})})(p)({...t,retryCount:0})})}},11043:function(t,e,n){n.d(e,{$S:function(){return ConnectorUnavailableReconnectingError},JK:function(){return ConnectorAccountNotFoundError},X4:function(){return ChainNotConfiguredError},XZ:function(){return ConnectorChainMismatchError},aH:function(){return ConnectorNotConnectedError},wi:function(){return ConnectorAlreadyConnectedError}});var r=n(41333);let ChainNotConfiguredError=class ChainNotConfiguredError extends r.G{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}};let ConnectorAlreadyConnectedError=class ConnectorAlreadyConnectedError extends r.G{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}};let ConnectorNotConnectedError=class ConnectorNotConnectedError extends r.G{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}};let ConnectorAccountNotFoundError=class ConnectorAccountNotFoundError extends r.G{constructor({address:t,connector:e}){super(`Account "${t}" not found for connector "${e.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}};let ConnectorChainMismatchError=class ConnectorChainMismatchError extends r.G{constructor({connectionChainId:t,connectorChainId:e}){super(`The current chain of the connector (id: ${e}) does not match the connection's chain (id: ${t}).`,{metaMessages:[`Current Chain ID:  ${e}`,`Expected Chain ID: ${t}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorChainMismatchError"})}};let ConnectorUnavailableReconnectingError=class ConnectorUnavailableReconnectingError extends r.G{constructor({connector:t}){super(`Connector "${t.name}" unavailable while reconnecting.`,{details:"During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`. All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored. This error commonly occurs for connectors that asynchronously inject after reconnection has already started."}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorUnavailableReconnectingError"})}}},35838:function(t,e,n){n.d(e,{M:function(){return ProviderNotFoundError},O:function(){return SwitchChainNotSupportedError}});var r=n(41333);let ProviderNotFoundError=class ProviderNotFoundError extends r.G{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}};let SwitchChainNotSupportedError=class SwitchChainNotSupportedError extends r.G{constructor({connector:t}){super(`"${t.name}" does not support programmatic chain switching.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SwitchChainNotSupportedError"})}}},15707:function(t,e,n){n.d(e,{OP:function(){return filterQueryOptions},if:function(){return structuralSharing},kq:function(){return hashFn}});var r=n(72549);function structuralSharing(t,e){return(0,r.Q$)(t,e)}function hashFn(t){return JSON.stringify(t,(t,e)=>!function(t){if(!hasObjectPrototype(t))return!1;let e=t.constructor;if(void 0===e)return!0;let n=e.prototype;return!!(hasObjectPrototype(n)&&n.hasOwnProperty("isPrototypeOf"))}(e)?"bigint"==typeof e?e.toString():e:Object.keys(e).sort().reduce((t,n)=>(t[n]=e[n],t),{}))}function hasObjectPrototype(t){return"[object Object]"===Object.prototype.toString.call(t)}function filterQueryOptions(t){let{_defaulted:e,behavior:n,gcTime:r,initialData:o,initialDataUpdatedAt:i,maxPages:s,meta:a,networkMode:u,queryFn:c,queryHash:h,queryKey:l,queryKeyHashFn:d,retry:p,retryDelay:f,structuralSharing:C,getPreviousPageParam:m,getNextPageParam:y,initialPageParam:b,_optimisticResults:g,enabled:v,notifyOnChangeProps:w,placeholderData:E,refetchInterval:O,refetchIntervalInBackground:S,refetchOnMount:M,refetchOnReconnect:x,refetchOnWindowFocus:P,retryOnMount:N,select:A,staleTime:R,suspense:F,throwOnError:j,config:G,connector:I,query:$,...k}=t;return k}},52014:function(t,e,n){n.d(e,{l:function(){return signMessage}});var r=n(56023),o=n(15025),i=n(50298);async function signMessage(t,{account:e=t.account,message:n}){if(!e)throw new o.o({docsPath:"/docs/actions/wallet/signMessage"});let s=(0,r.T)(e);if(s.signMessage)return s.signMessage({message:n});let a="string"==typeof n?(0,i.$G)(n):n.raw instanceof Uint8Array?(0,i.NC)(n.raw):n.raw;return t.request({method:"personal_sign",params:[a,s.address]},{retryCount:0})}},15025:function(t,e,n){n.d(e,{Y:function(){return AccountTypeNotSupportedError},o:function(){return AccountNotFoundError}});var r=n(86438);let AccountNotFoundError=class AccountNotFoundError extends r.G{constructor({docsPath:t}={}){super("Could not find an Account to execute with this Action.\nPlease provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.",{docsPath:t,docsSlug:"account",name:"AccountNotFoundError"})}};let AccountTypeNotSupportedError=class AccountTypeNotSupportedError extends r.G{constructor({docsPath:t,metaMessages:e,type:n}){super(`Account type "${n}" is not supported.`,{docsPath:t,metaMessages:e,name:"AccountTypeNotSupportedError"})}}},69245:function(t,e,n){n.d(e,{o:function(){return useSwitchChain}});var r=n(95499),o=n(11043),i=n(35838);async function switchChain(t,e){let{addEthereumChainParameter:n,chainId:r}=e,s=t.state.connections.get(e.connector?.uid??t.state.current);if(s){let t=s.connector;if(!t.switchChain)throw new i.O({connector:t});let e=await t.switchChain({addEthereumChainParameter:n,chainId:r});return e}let a=t.chains.find(t=>t.id===r);if(!a)throw new o.X4;return t.setState(t=>({...t,chainId:r})),a}var s=n(64401);let a=[];function getChains(t){let e=t.chains;return(0,s.v)(a,e)?a:(a=e,e)}var u=n(77317),c=n(92738);function useSwitchChain(t={}){let{mutation:e}=t,n=(0,c.Z)(t),{mutate:o,mutateAsync:i,...s}=(0,r.D)({...e,mutationFn:t=>switchChain(n,t),mutationKey:["switchChain"]});return{...s,chains:function(t={}){let e=(0,c.Z)(t);return(0,u.useSyncExternalStore)(t=>(function(t,e){let{onChange:n}=e;return t._internal.chains.subscribe((t,e)=>{n(t,e)})})(e,{onChange:t}),()=>getChains(e),()=>getChains(e))}({config:n}),switchChain:o,switchChainAsync:i}}},9520:function(t,e,n){n.d(e,{aM:function(){return useQuery}});var r=n(64370),o=n(15707);function useQuery(t){let e=(0,r.a)({...t,queryKeyHashFn:o.kq});return e.queryKey=t.queryKey,e}}}]);