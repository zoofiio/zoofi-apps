"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1331],{41331:function(t,e,a){a.d(e,{p:function(){return useWalletClient}});var n=a(83037),r=a(1554),s=a(31236);async function addChain(t,{chain:e}){let{id:a,name:n,nativeCurrency:r,rpcUrls:o,blockExplorers:i}=e;await t.request({method:"wallet_addEthereumChain",params:[{chainId:(0,s.eC)(a),chainName:n,nativeCurrency:r,rpcUrls:o.default.http,blockExplorerUrls:i?Object.values(i).map(({url:t})=>t):void 0}]},{dedupe:!0,retryCount:0})}var o=a(83148),i=a(11266),c=a(95280),u=a(75775),l=a(23318),d=a(50221);function assertCurrentChain({chain:t,currentChainId:e}){if(!t)throw new d.Bk;if(e!==t.id)throw new d.Yl({chain:t,currentChainId:e})}var h=a(35848),w=a(99711),p=a(54200);function getTransactionError(t,{docsPath:e,...a}){let n=(()=>{let e=(0,p.k)(t,a);return e instanceof h.cj?t:e})();return new w.mk(n,{docsPath:e,...a})}var m=a(94380),f=a(52893),C=a(27289),g=a(56673),y=a(95496),T=a(56197),v=a(52002);let b=new g.k(128);async function sendTransaction(t,e){let{account:a=t.account,chain:n=t.chain,accessList:s,authorizationList:o,blobs:d,data:h,gas:w,gasPrice:p,maxFeePerBlobGas:g,maxFeePerGas:q,maxPriorityFeePerGas:A,nonce:P,type:_,value:I,...E}=e;if(void 0===a)throw new c.o({docsPath:"/docs/actions/wallet/sendTransaction"});let S=a?(0,i.T)(a):null;try{(0,y.F)(e);let a=await (async()=>e.to?e.to:null!==e.to&&o&&o.length>0?await (0,l.z)({authorization:o[0]}).catch(()=>{throw new u.G("`to` is required. Could not infer from `authorizationList`.")}):void 0)();if(S?.type==="json-rpc"||null===S){let e;null!==n&&(e=await (0,C.s)(t,r.L,"getChainId")({}),assertCurrentChain({currentChainId:e,chain:n}));let i=t.chain?.formatters?.transactionRequest?.format,c=i||f.tG,u=c({...(0,m.K)(E,{format:i}),accessList:s,authorizationList:o,blobs:d,chainId:e,data:h,from:S?.address,gas:w,gasPrice:p,maxFeePerBlobGas:g,maxFeePerGas:q,maxPriorityFeePerGas:A,nonce:P,to:a,type:_,value:I}),l=b.get(t.uid);try{return await t.request({method:l?"wallet_sendTransaction":"eth_sendTransaction",params:[u]},{retryCount:0})}catch(e){if(!1===l)throw e;if("InvalidInputRpcError"===e.name||"InvalidParamsRpcError"===e.name||"MethodNotFoundRpcError"===e.name||"MethodNotSupportedRpcError"===e.name)return await t.request({method:"wallet_sendTransaction",params:[u]},{retryCount:0}).then(e=>(b.set(t.uid,!0),e)).catch(a=>{if("MethodNotFoundRpcError"===a.name||"MethodNotSupportedRpcError"===a.name)throw b.set(t.uid,!1),e;throw a});throw e}}if(S?.type==="local"){let e=await (0,C.s)(t,T.ZE,"prepareTransactionRequest")({account:S,accessList:s,authorizationList:o,blobs:d,chain:n,data:h,gas:w,gasPrice:p,maxFeePerBlobGas:g,maxFeePerGas:q,maxPriorityFeePerGas:A,nonce:P,nonceManager:S.nonceManager,parameters:[...T.QZ,"sidecars"],type:_,value:I,...E,to:a}),r=n?.serializers?.transaction,i=await S.signTransaction(e,{serializer:r});return await (0,C.s)(t,v.p,"sendRawTransaction")({serializedTransaction:i})}if(S?.type==="smart")throw new c.Y({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"});throw new c.Y({docsPath:"/docs/actions/wallet/sendTransaction",type:S?.type})}catch(t){if(t instanceof c.Y)throw t;throw getTransactionError(t,{...e,account:S,chain:e.chain||void 0})}}var q=a(5708);async function getAddresses(t){if(t.account?.type==="local")return[t.account.address];let e=await t.request({method:"eth_accounts"},{dedupe:!0});return e.map(t=>(0,q.x)(t))}var A=a(26327),P=a(77435),_=a(27190),I=a(86131),E=a(31909),S=a(34113),N=a(20504);let z="0x5792579257925792579257925792579257925792579257925792579257925792",R=(0,s.eC)(0,{size:32});async function sendCalls(t,e){let{account:a=t.account,capabilities:n,chain:r=t.chain,experimental_fallback:o,experimental_fallbackDelay:l=32,forceAtomic:d=!1,id:h,version:w="2.0.0"}=e;if(void 0===a)throw new c.o({docsPath:"/docs/actions/wallet/sendCalls"});let p=a?(0,i.T)(a):null,m=e.calls.map(t=>{let e=t.abi?(0,S.R)({abi:t.abi,functionName:t.functionName,args:t.args}):t.data;return{data:e,to:t.to,value:t.value?(0,s.eC)(t.value):void 0}});try{let e=await t.request({method:"wallet_sendCalls",params:[{atomicRequired:d,calls:m,capabilities:n,chainId:(0,s.eC)(r.id),from:p?.address,id:h,version:w}]},{retryCount:0});if("string"==typeof e)return{id:e};return e}catch(a){if(o&&("MethodNotFoundRpcError"===a.name||"MethodNotSupportedRpcError"===a.name||a.details.toLowerCase().includes("does not exist / is not available")||a.details.toLowerCase().includes("missing or invalid. request()")||a.details.toLowerCase().includes("did not match any variant of untagged enum"))){if(n){let t=Object.values(n).some(t=>!t.optional);if(t){let t="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new E.vl(new u.G(t,{details:t}))}}if(d&&m.length>1){let t="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new E.r0(new u.G(t,{details:t}))}let e=[];for(let a of m){let n=sendTransaction(t,{account:p,chain:r,data:a.data,to:a.to,value:a.value?(0,_.y_)(a.value):void 0});e.push(n),l>0&&await new Promise(t=>setTimeout(t,l))}let a=await Promise.allSettled(e);if(a.every(t=>"rejected"===t.status))throw a[0].reason;let o=a.map(t=>"fulfilled"===t.status?t.value:R);return{id:(0,N.zo)([...o,(0,s.eC)(r.id,{size:32}),z])}}throw getTransactionError(a,{...e,account:p,chain:e.chain})}}async function getCallsStatus(t,e){async function getStatus(e){let a=e.endsWith(z.slice(2));if(a){let a=(0,P.f)((0,A.p5)(e,-64,-32)),n=(0,A.p5)(e,0,-64).slice(2).match(/.{1,64}/g),r=await Promise.all(n.map(e=>R.slice(2)!==e?t.request({method:"eth_getTransactionReceipt",params:[`0x${e}`]},{dedupe:!0}):void 0)),s=r.some(t=>null===t)?100:r.every(t=>t?.status==="0x1")?200:r.every(t=>t?.status==="0x0")?500:600;return{atomic:!1,chainId:(0,_.ly)(a),receipts:r.filter(Boolean),status:s,version:"2.0.0"}}return t.request({method:"wallet_getCallsStatus",params:[e]})}let{atomic:a=!1,chainId:n,receipts:r,version:s="2.0.0",...o}=await getStatus(e.id),[i,c]=(()=>{let t=o.status;return t>=100&&t<200?["pending",t]:t>=200&&t<300?["success",t]:t>=300&&t<700?["failure",t]:"CONFIRMED"===t?["success",200]:"PENDING"===t?["pending",100]:[void 0,t]})();return{...o,atomic:a,chainId:n?(0,_.ly)(n):void 0,receipts:r?.map(t=>({...t,blockNumber:_.y_(t.blockNumber),gasUsed:_.y_(t.gasUsed),status:I.ew[t.status]}))??[],statusCode:c,status:i,version:s}}async function getCapabilities(t,e={}){let{account:a=t.account,chainId:n}=e,r=a?(0,i.T)(a):void 0,o=n?[r?.address,[(0,s.eC)(n)]]:[r?.address],c=await t.request({method:"wallet_getCapabilities",params:o}),u={};for(let[t,e]of Object.entries(c))for(let[a,n]of(u[Number(t)]={},Object.entries(e)))"addSubAccount"===a&&(a="unstable_addSubAccount"),u[Number(t)][a]=n;return"number"==typeof n?u[n]:u}async function getPermissions(t){let e=await t.request({method:"wallet_getPermissions"},{dedupe:!0});return e}var x=a(97995),F=a(60418);async function prepareAuthorization(t,e){let{account:a=t.account,chainId:n,nonce:s}=e;if(!a)throw new c.o({docsPath:"/docs/eip7702/prepareAuthorization"});let o=(0,i.T)(a),u=(()=>{if(e.executor)return"self"===e.executor?e.executor:(0,i.T)(e.executor)})(),l={address:e.contractAddress??e.address,chainId:n,nonce:s};return void 0===l.chainId&&(l.chainId=t.chain?.id??await (0,C.s)(t,r.L,"getChainId")({})),void 0===l.nonce&&(l.nonce=await (0,C.s)(t,F.K,"getTransactionCount")({address:o.address,blockTag:"pending"}),("self"===u||u?.address&&(0,x.E)(u.address,o.address))&&(l.nonce+=1)),l}async function requestAddresses(t){let e=await t.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0});return e.map(t=>(0,q.K)(t))}async function requestPermissions(t,e){return t.request({method:"wallet_requestPermissions",params:[e]},{retryCount:0})}async function showCallsStatus(t,e){let{id:a}=e;await t.request({method:"wallet_showCallsStatus",params:[a]})}async function signAuthorization(t,e){let{account:a=t.account}=e;if(!a)throw new c.o({docsPath:"/docs/eip7702/signAuthorization"});let n=(0,i.T)(a);if(!n.signAuthorization)throw new c.Y({docsPath:"/docs/eip7702/signAuthorization",metaMessages:["The `signAuthorization` Action does not support JSON-RPC Accounts."],type:n.type});let r=await prepareAuthorization(t,e);return n.signAuthorization(r)}var k=a(1318);async function signTransaction(t,e){let{account:a=t.account,chain:n=t.chain,...o}=e;if(!a)throw new c.o({docsPath:"/docs/actions/wallet/signTransaction"});let u=(0,i.T)(a);(0,y.F)({account:u,...e});let l=await (0,C.s)(t,r.L,"getChainId")({});null!==n&&assertCurrentChain({currentChainId:l,chain:n});let d=n?.formatters||t.chain?.formatters,h=d?.transactionRequest?.format||f.tG;return u.signTransaction?u.signTransaction({...o,chainId:l},{serializer:t.chain?.serializers?.transaction}):await t.request({method:"eth_signTransaction",params:[{...h(o),chainId:(0,s.eC)(l),from:u.address}]},{retryCount:0})}var M=a(78851);async function signTypedData(t,e){let{account:a=t.account,domain:n,message:r,primaryType:s}=e;if(!a)throw new c.o({docsPath:"/docs/actions/wallet/signTypedData"});let o=(0,i.T)(a),u={EIP712Domain:(0,M.cj)({domain:n}),...e.types};if((0,M.iC)({domain:n,message:r,primaryType:s,types:u}),o.signTypedData)return o.signTypedData({domain:n,message:r,primaryType:s,types:u});let l=(0,M.H6)({domain:n,message:r,primaryType:s,types:u});return t.request({method:"eth_signTypedData_v4",params:[o.address,l]},{retryCount:0})}async function switchChain(t,{id:e}){await t.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,s.eC)(e)}]},{retryCount:0})}var O=a(40913),D=a(63714),L=a(8719),j=a(67103);async function waitForCallsStatus(t,e){let a;let{id:n,pollingInterval:r=t.pollingInterval,status:s=({statusCode:t})=>t>=200,timeout:o=6e4}=e,i=(0,j.P)(["waitForCallsStatus",t.uid,n]),{promise:c,resolve:u,reject:l}=(0,L.n)(),d=(0,O.N7)(i,{resolve:u,reject:l},e=>{let o=(0,D.$)(async()=>{let done=t=>{clearTimeout(a),o(),t(),d()};try{let a=await getCallsStatus(t,{id:n});if(!s(a))return;done(()=>e.resolve(a))}catch(t){done(()=>e.reject(t))}},{interval:r,emitOnBegin:!0});return o});return a=o?setTimeout(()=>{d(),clearTimeout(a),l(new WaitForCallsStatusTimeoutError({id:n}))},o):void 0,await c}let WaitForCallsStatusTimeoutError=class WaitForCallsStatusTimeoutError extends u.G{constructor({id:t}){super(`Timed out while waiting for call bundle with id "${t}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}};async function watchAsset(t,e){let a=await t.request({method:"wallet_watchAsset",params:e},{retryCount:0});return a}var U=a(75509);async function writeContract(t,e){let{abi:a,account:n=t.account,address:r,args:s,dataSuffix:o,functionName:u,...l}=e;if(void 0===n)throw new c.o({docsPath:"/docs/contract/writeContract"});let d=n?(0,i.T)(n):null,h=(0,S.R)({abi:a,args:s,functionName:u});try{return await (0,C.s)(t,sendTransaction,"sendTransaction")({data:`${h}${o?o.replace("0x",""):""}`,to:r,account:d,...l})}catch(t){throw(0,U.S)(t,{abi:a,address:r,args:s,docsPath:"/docs/contract/writeContract",functionName:u,sender:d?.address})}}function walletActions(t){return{addChain:e=>addChain(t,e),deployContract:e=>(function(t,e){let{abi:a,args:n,bytecode:r,...s}=e,i=(0,o.w)({abi:a,args:n,bytecode:r});return sendTransaction(t,{...s,...s.authorizationList?{to:null}:{},data:i})})(t,e),getAddresses:()=>getAddresses(t),getCallsStatus:e=>getCallsStatus(t,e),getCapabilities:e=>getCapabilities(t,e),getChainId:()=>(0,r.L)(t),getPermissions:()=>getPermissions(t),prepareAuthorization:e=>prepareAuthorization(t,e),prepareTransactionRequest:e=>(0,T.ZE)(t,e),requestAddresses:()=>requestAddresses(t),requestPermissions:e=>requestPermissions(t,e),sendCalls:e=>sendCalls(t,e),sendRawTransaction:e=>(0,v.p)(t,e),sendTransaction:e=>sendTransaction(t,e),showCallsStatus:e=>showCallsStatus(t,e),signAuthorization:e=>signAuthorization(t,e),signMessage:e=>(0,k.l)(t,e),signTransaction:e=>signTransaction(t,e),signTypedData:e=>signTypedData(t,e),switchChain:e=>switchChain(t,e),waitForCallsStatus:e=>waitForCallsStatus(t,e),watchAsset:e=>watchAsset(t,e),writeContract:e=>writeContract(t,e)}}var W=a(97917);async function getWalletClient(t,e={}){let a=await (0,W.e)(t,e);return a.extend(walletActions)}var G=a(48481),Y=a(77317),K=a(82714),$=a(42302),Z=a(9309),B=a(63880);function useWalletClient(t={}){let{query:e={},...a}=t,r=(0,B.Z)(a),s=(0,n.NL)(),{address:o,connector:i,status:c}=(0,$.m)({config:r}),u=(0,Z.x)({config:r}),l=t.connector??i,{queryKey:d,...h}=function(t,e={}){return{gcTime:0,async queryFn({queryKey:a}){let{connector:n}=e,{connectorUid:r,scopeKey:s,...o}=a[1];return getWalletClient(t,{...o,connector:n})},queryKey:function(t={}){let{connector:e,...a}=t;return["walletClient",{...(0,G.OP)(a),connectorUid:e?.uid}]}(e)}}(r,{...t,chainId:t.chainId??u,connector:t.connector??i}),w=!!(("connected"===c||"reconnecting"===c&&l?.getProvider)&&(e.enabled??!0)),p=(0,Y.useRef)(o);return(0,Y.useEffect)(()=>{let t=p.current;!o&&t?(s.removeQueries({queryKey:d}),p.current=void 0):o!==t&&(s.invalidateQueries({queryKey:d}),p.current=o)},[o,s]),(0,K.aM)({...e,...h,queryKey:d,enabled:w,staleTime:Number.POSITIVE_INFINITY})}}}]);